{
 "cells": [
  {
   "cell_type": "raw",
   "id": "bba652ce",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Level-1 Dataset\n",
    "===============\n",
    "The ESIS Level-1 data product includes applying the following steps to the Level-0 data:\n",
    "\n",
    "* Bias subtraction\n",
    "* Dark frame subtraction\n",
    "* Non-active (NAP) pixel removal\n",
    "* Conversion to electrons\n",
    "* Cosmic ray removal\n",
    "\n",
    "These steps consist of all the effects that need to be accounted for before we transform\n",
    "into skyplane coordinates.\n",
    "All of these steps are packaged into the :func:`esis.flights.f1.data.level_1` function,\n",
    "but this notebook starts from the Level-0 dataset and examines each indivdual step."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e0c78b0202c08cc0",
   "metadata": {},
   "outputs": [],
   "source": [
    "%reload_ext autoreload\n",
    "%autoreload 2\n",
    "# %matplotlib notebook+"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6098fc9709ad1b15",
   "metadata": {},
   "outputs": [],
   "source": [
    "import IPython.display\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import astropy.units as u\n",
    "import astropy.visualization\n",
    "import named_arrays as na\n",
    "import esis"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2fa28361",
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.rcParams[\"animation.embed_limit\"] = 50"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "abb9b243",
   "metadata": {},
   "outputs": [],
   "source": [
    "astropy.visualization.quantity_support();"
   ]
  },
  {
   "cell_type": "raw",
   "id": "9bee6912",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Bias Subtraction\n",
    "---------------------------\n",
    "The bias (or pedestal) is an offset charge used to keep all the outputs positive.\n",
    "The ESIS senors have 50 blank columns and 2 overscan columns on each tap which are not sensitive to\n",
    "light and can be used to estimate the bias.\n",
    "In :doc:`msfc_ccd:reports/bias`,\n",
    "we found that using only the overscan columns resulted in the\n",
    "best bias subtraction.\n",
    "To check this result, we'll start by loading the Level-0 dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "87473ea1f4ed5335",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_0 = esis.flights.f1.data.level_0()"
   ]
  },
  {
   "cell_type": "raw",
   "id": "17f6dc10",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Create a copy of the time array in :class:`datetime.datetime` format for easier plotting with :mod:`matplotlib`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2c2bcba6335f55a2",
   "metadata": {},
   "outputs": [],
   "source": [
    "time = level_0.inputs.time\n",
    "time = time.replace(ndarray=time.ndarray.datetime)"
   ]
  },
  {
   "cell_type": "raw",
   "id": "019233c7",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Estimate and remove the bias from all the images.\n",
    "We'll place the results into a variable called `level_1` which we'll apply further operations to construct the final Level-1 dataset."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "10818edb83ed5c84",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1 = level_0.unbiased"
   ]
  },
  {
   "cell_type": "raw",
   "id": "0e21f819",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Plot the average bias-subtracted signal as a function of time\n",
    "and the intervals containing the light and dark frames."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e4cb1e6595e0757c",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(\n",
    "    figsize=(6, 2.5),\n",
    "    constrained_layout=True,\n",
    ")\n",
    "na.plt.plot(\n",
    "    time,\n",
    "    level_1.outputs.mean((level_1.axis_x, level_1.axis_y)),\n",
    "    axis=level_1.axis_time,\n",
    "    label=level_1.channel,\n",
    "    drawstyle='steps-mid',\n",
    ")\n",
    "ax.axvspan(\n",
    "    xmin=level_1.lights.inputs.time_start.ndarray.min().datetime,\n",
    "    xmax=level_1.lights.inputs.time_end.ndarray.max().datetime,\n",
    "    alpha=0.3,\n",
    "    label=\"lights\",\n",
    ")\n",
    "ax.axvspan(\n",
    "    xmin=level_1.darks_up.inputs.time_start.ndarray.min().datetime,\n",
    "    xmax=level_1.darks_up.inputs.time_end.ndarray.max().datetime,\n",
    "    alpha=0.3,\n",
    "    label=\"darks\",\n",
    "    color=\"gray\",\n",
    ")\n",
    "ax.axvspan(\n",
    "    xmin=level_1.darks_down.inputs.time_start.ndarray.min().datetime,\n",
    "    xmax=level_1.darks_down.inputs.time_end.ndarray.max().datetime,\n",
    "    alpha=0.3,\n",
    "    color=\"gray\",\n",
    ")\n",
    "ax.set_xlabel(\"time (UTC)\")\n",
    "ax.set_ylabel(\"mean intensity (DN)\")\n",
    "ax.legend();"
   ]
  },
  {
   "cell_type": "raw",
   "id": "197ff3ef",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Create an animation of all the dark frames."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1e585047fe0b8172",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1.darks.to_jshtml()"
   ]
  },
  {
   "cell_type": "raw",
   "id": "fb313843",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Split the dark frames into separate images for each tap to inspect the quality of the bias subtraction."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "160f06c2b273def4",
   "metadata": {},
   "outputs": [],
   "source": [
    "taps = level_1.darks.taps"
   ]
  },
  {
   "cell_type": "raw",
   "id": "fa9ea9ee",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Plot the time/row-averaged signal as a function of column for every tap of every dark frame."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "209f75cca9946af1",
   "metadata": {},
   "outputs": [],
   "source": [
    "axes_tap_xy = (taps.axis_tap_x, taps.axis_tap_y)\n",
    "axis_tap_xy = \"tap_xy\"\n",
    "tap_labels = taps.label.combine_axes(axes_tap_xy, axis_tap_xy)\n",
    "taps = taps.combine_axes(axes_tap_xy, axis_tap_xy)\n",
    "\n",
    "fig, ax = na.plt.subplots(\n",
    "    axis_rows=level_0.axis_channel,\n",
    "    axis_cols=axis_tap_xy,\n",
    "    nrows=taps.shape[level_0.axis_channel],\n",
    "    ncols=taps.shape[axis_tap_xy],\n",
    "    sharex=True,\n",
    "    sharey=True,\n",
    "    constrained_layout=True,\n",
    "    origin=\"upper\",\n",
    ")\n",
    "na.plt.plot(\n",
    "    taps.outputs.mean_trimmed(.01, (level_0.axis_time, level_0.axis_y)),\n",
    "    axis=level_0.axis_x,\n",
    "    ax=ax,\n",
    ")\n",
    "na.plt.set_ylim(\n",
    "    bottom=-1,\n",
    "    top=1,\n",
    "    ax=ax,\n",
    ")\n",
    "na.plt.axvspan(\n",
    "    xmin=0,\n",
    "    xmax=taps.camera.sensor.num_blank,\n",
    "    color=\"green\",\n",
    "    alpha=0.2,\n",
    "    ax=ax,\n",
    "    label=\"blank\",\n",
    ")\n",
    "na.plt.axvspan(\n",
    "    xmin=taps.num_x - taps.camera.sensor.num_overscan,\n",
    "    xmax=taps.num_x,\n",
    "    color=\"red\",\n",
    "    alpha=0.2,\n",
    "    ax=ax,\n",
    "    label=\"overscan\",\n",
    ")\n",
    "na.plt.set_xlabel(\"columns\", ax=ax[{level_0.axis_channel: ~0}])\n",
    "na.plt.text(\n",
    "    x=0.5,\n",
    "    y=1.02,\n",
    "    s=tap_labels[{level_0.axis_channel: 0}],\n",
    "    ax=ax[{level_0.axis_channel: 0}],\n",
    "    transform=na.plt.transAxes(ax[{level_0.axis_channel: 0}]),\n",
    "    ha=\"center\",\n",
    "    va=\"bottom\",\n",
    ")\n",
    "na.plt.text(\n",
    "    x=1.02,\n",
    "    y=0.5,\n",
    "    s=level_0.channel,\n",
    "    ax=ax[{axis_tap_xy: ~0}],\n",
    "    transform=na.plt.transAxes(ax[{axis_tap_xy: ~0}]),\n",
    "    ha=\"left\",\n",
    "    va=\"center\",\n",
    ");\n",
    "# ax.ndarray.flat[~0].legend();"
   ]
  },
  {
   "cell_type": "raw",
   "id": "9a5897cb",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Cropping Non-Active Pixels\n",
    "--------------------------\n",
    "The blank and overscan columns are useful for estimating the bias,\n",
    "but they are not sensitive to light and need to be removed to\n",
    "make a continuous image.\n",
    "We can remove these pixels easily using the :attr:`~esis.data.Level_0.active`\n",
    "property."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0aad43b0",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "30c267ae4450663f",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1 = level_1.active"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e8afd63b",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1.shape"
   ]
  },
  {
   "cell_type": "raw",
   "id": "9ca2aee5",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "From the printed shapes, notice how the ``detector_x`` axis is smaller by 104 pixels."
   ]
  },
  {
   "cell_type": "raw",
   "id": "bdc90879",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Conversion to Electrons\n",
    "-----------------------\n",
    "To interpret the images in terms of electrons,\n",
    "multiply the values of each image by a tap-dependent gain value."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c66f78b3",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1.outputs.ndarray.mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2ba62cc5",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1 = level_1.electrons"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "06a9df49",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1.outputs.ndarray.mean()"
   ]
  },
  {
   "cell_type": "raw",
   "id": "dfe39c45",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Dark Subtraction\n",
    "----------------\n",
    "To calculate the master dark frame,\n",
    "we'll use the :attr:`~esis.data.Level_0.dark`\n",
    "property which despikes the dark frame sequence,\n",
    "and then take the mean along the time axis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2963fe969ee3a2c6",
   "metadata": {},
   "outputs": [],
   "source": [
    "dark = level_1.dark"
   ]
  },
  {
   "cell_type": "raw",
   "id": "6854be50",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Plot the dark frame for each channel to inspect"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e02eff69",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "fig, ax = na.plt.subplots(\n",
    "    axis_rows=dark.axis_channel,\n",
    "    nrows=dark.shape[dark.axis_channel],\n",
    "    sharex=True,\n",
    "    sharey=True,\n",
    "    constrained_layout=True,\n",
    "    figsize=(5, 8),\n",
    "    origin=\"upper\",\n",
    ")\n",
    "na.plt.set_xlabel(\"detector $x$ (pix)\", ax=ax[{dark.axis_channel: ~0}])\n",
    "na.plt.set_ylabel(\"detector $y$ (pix)\", ax=ax)\n",
    "\n",
    "norm = plt.Normalize(-5, 5)\n",
    "\n",
    "colorizer = plt.Colorizer(norm=norm)\n",
    "\n",
    "i = {dark.axis_time: 0}\n",
    "\n",
    "na.plt.pcolormesh(\n",
    "    dark[i].inputs.pixel.x,\n",
    "    dark[i].inputs.pixel.y,\n",
    "    C=dark[i].outputs,\n",
    "    ax=ax,\n",
    "    colorizer=colorizer,\n",
    ")\n",
    "na.plt.text(\n",
    "    x=0.5,\n",
    "    y=1.01,\n",
    "    s=dark[i].channel,\n",
    "    transform=na.plt.transAxes(ax),\n",
    "    ax=ax,\n",
    "    ha=\"center\",\n",
    "    va=\"bottom\",\n",
    ")\n",
    "na.plt.set_aspect(\"equal\", ax=ax)\n",
    "\n",
    "plt.colorbar(\n",
    "    mappable=plt.cm.ScalarMappable(colorizer=colorizer),\n",
    "    ax=ax.ndarray,\n",
    "    label=f\"signal ({dark.outputs.unit:latex_inline})\",\n",
    ");"
   ]
  },
  {
   "cell_type": "raw",
   "id": "28a63ad9",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Subtract the master dark from each frame"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bbade136",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1 = level_1.dark_subtracted"
   ]
  },
  {
   "cell_type": "raw",
   "id": "0b1010fe",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Create a histogram of the values of all the dark-subtracted dark frames to inpect their distribution."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "94c2f8c1",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "axis_txy = (level_1.axis_time, level_1.axis_x, level_1.axis_y)\n",
    "hist = na.histogram(\n",
    "    level_1.darks.outputs, \n",
    "    axis=axis_txy,\n",
    "    bins=dict(values=101),\n",
    "    min=-25 * u.electron,\n",
    "    max=+25 * u.electron,\n",
    "    density=True,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e39b0f54",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(\n",
    "    constrained_layout=True,\n",
    ")\n",
    "na.plt.stairs(\n",
    "    hist.inputs,\n",
    "    hist.outputs,\n",
    "    ax=ax,\n",
    "    axis=\"values\",\n",
    "    label=level_1.channel\n",
    ")\n",
    "na.plt.axvline(0, ax=ax, color=\"black\", linestyle=\"--\")\n",
    "na.plt.set_ylabel(\"probability density\", ax=ax)\n",
    "na.plt.set_xlabel(f\"dark signal ({ax.get_xlabel()})\", ax=ax)\n",
    "ax.legend();"
   ]
  },
  {
   "cell_type": "raw",
   "id": "cd6f65fc",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Compute the standard deviation of each channel.\n",
    "This is equivalent to the read noise for each channel."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "25b91dc6",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1.darks.despiked.outputs.std(axis_txy).ndarray"
   ]
  },
  {
   "cell_type": "raw",
   "id": "a046aeab",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Isolate only the frames with solar images since we no longer need the dark frames."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "48fc4ecf",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1 = level_1.lights"
   ]
  },
  {
   "cell_type": "raw",
   "id": "40e3221f",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Cosmic Ray Removal\n",
    "------------------\n",
    "All of the images have cosmic ray spikes that must be removed before proceeding.\n",
    "For comparison, we will take the maximum of the current data along the time axis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8f8fdfa0",
   "metadata": {},
   "outputs": [],
   "source": [
    "original_max = np.max(level_1, axis=level_1.axis_time)"
   ]
  },
  {
   "cell_type": "raw",
   "id": "8ec222c9",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Remove spikes from all the solar images using :func:`astroscrappy.detect_cosmics()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8374badbba8acb80",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1 = level_1.despiked"
   ]
  },
  {
   "cell_type": "raw",
   "id": "4a2c93ae",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Blink the original maximum frame against the despiked maximum frame"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8f9d26f2",
   "metadata": {},
   "outputs": [],
   "source": [
    "despiked_max = level_1.max(level_1.axis_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1b33e3e5",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "fig, ax = na.plt.subplots(\n",
    "    axis_rows=dark.axis_channel,\n",
    "    nrows=dark.shape[dark.axis_channel],\n",
    "    sharex=True,\n",
    "    sharey=True,\n",
    "    constrained_layout=True,\n",
    "    figsize=(5, 9),\n",
    "    origin=\"upper\",\n",
    ")\n",
    "\n",
    "norm = plt.Normalize(\n",
    "    vmin=0,\n",
    "    vmax=despiked_max.outputs.percentile(99).ndarray.value,\n",
    ")\n",
    "\n",
    "colorizer = plt.Colorizer(norm=norm)\n",
    "\n",
    "i = {level_1.axis_time: 0}\n",
    "\n",
    "ani = na.plt.pcolormovie(\n",
    "    na.ScalarArray(\n",
    "        ndarray=np.array([\"\", \"\"]),\n",
    "        axes=\"blink\",\n",
    "    ),\n",
    "    level_1[i].inputs.pixel.x,\n",
    "    level_1[i].inputs.pixel.y,\n",
    "    C=na.stack(\n",
    "        arrays=[\n",
    "            original_max.outputs[i],\n",
    "            despiked_max.outputs[i],\n",
    "        ],\n",
    "        axis=\"blink\",\n",
    "    ),\n",
    "    axis_time=\"blink\",\n",
    "    ax=ax,\n",
    "    kwargs_pcolormesh=dict(\n",
    "        colorizer=colorizer,\n",
    "    ),\n",
    "    kwargs_animation=dict(\n",
    "        interval=1000,\n",
    "    )\n",
    ")\n",
    "na.plt.text(\n",
    "    x=0.5,\n",
    "    y=1.01,\n",
    "    s=dark[i].channel,\n",
    "    transform=na.plt.transAxes(ax),\n",
    "    ax=ax,\n",
    "    ha=\"center\",\n",
    "    va=\"bottom\",\n",
    ")\n",
    "na.plt.set_aspect(\"equal\", ax=ax)\n",
    "na.plt.set_xlabel(\"detector $x$ (pix)\", ax=ax[{dark.axis_channel: ~0}])\n",
    "na.plt.set_ylabel(\"detector $y$ (pix)\", ax=ax)\n",
    "plt.colorbar(\n",
    "    mappable=plt.cm.ScalarMappable(colorizer=colorizer),\n",
    "    ax=ax.ndarray,\n",
    "    label=f\"signal ({dark.outputs.unit:latex_inline})\",\n",
    ");\n",
    "plt.close(fig)\n",
    "IPython.display.HTML(ani.to_jshtml())"
   ]
  },
  {
   "cell_type": "raw",
   "id": "d5537381",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    "Plot the final Level-1 images"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bfa8e0ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "level_1.to_jshtml()"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Raw Cell Format",
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
